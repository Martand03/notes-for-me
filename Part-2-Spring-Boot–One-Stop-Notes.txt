ðŸ”¹ 1. Core Annotations

@SpringBootApplication

Meta-annotation = @Configuration + @EnableAutoConfiguration + @ComponentScan.

Entry point for Spring Boot apps.

@RestController

Combines @Controller + @ResponseBody.

Returns JSON/XML instead of views.

@Service

Marks business logic layer. Helps with readability.

@Repository

Marks DAO layer. Converts DB exceptions into Springâ€™s DataAccessException.

@Component

Generic stereotype for beans when none of the above apply.

@Autowired

Injects dependencies automatically.

Prefer constructor injection (better for immutability & testing).

Interview Q: Difference between @Component, @Service, @Repository?
ðŸ‘‰ They are functionally same (all detected via component scan), but semantically different for readability and exception translation.

ðŸ”¹ 2. Spring Bean Lifecycle

Lifecycle Steps:

Instantiation â†’ Bean created.

Dependency Injection â†’ Properties injected.

Aware Interfaces (if implemented):

BeanNameAware, BeanFactoryAware, ApplicationContextAware.

Initialization:

@PostConstruct or afterPropertiesSet() (from InitializingBean).

Ready to Use â†’ Bean available.

Destruction:

@PreDestroy or destroy() (from DisposableBean).

Example:

@Component
class ExampleBean implements InitializingBean, DisposableBean {
    @PostConstruct
    public void init() { System.out.println("PostConstruct"); }
    @Override
    public void afterPropertiesSet() { System.out.println("InitializingBean"); }
    @PreDestroy
    public void cleanup() { System.out.println("PreDestroy"); }
    @Override
    public void destroy() { System.out.println("DisposableBean"); }
}

ðŸ”¹ 3. AOP (Aspect-Oriented Programming)

AOP â†’ separates cross-cutting concerns (logging, security, transactions).

Implemented using proxies in Spring.

Key Terms:

Aspect â†’ class containing cross-cutting concern.

Join Point â†’ point in execution (method call).

Advice â†’ action taken at join point (@Before, @After, @Around).

Pointcut â†’ expression defining where advice applies.

Example Logging Aspect:

@Aspect
@Component
class LoggingAspect {
    @Before("execution(* com.app.service.*.*(..))")
    public void logBefore(JoinPoint jp) {
        System.out.println("Executing: " + jp.getSignature());
    }
}


Interview Q: How does Spring AOP work internally?
ðŸ‘‰ It uses JDK dynamic proxies for interfaces, and CGLIB proxies for classes.

ðŸ”¹ 4. REST APIs in Spring Boot

CRUD Example:

@RestController
@RequestMapping("/users")
class UserController {
    private final UserService service;

    UserController(UserService service) { this.service = service; }

    @PostMapping
    ResponseEntity<UserDto> create(@Valid @RequestBody UserDto dto) {
        return ResponseEntity.status(HttpStatus.CREATED).body(service.save(dto));
    }

    @GetMapping("/{id}")
    ResponseEntity<UserDto> get(@PathVariable Long id) {
        return ResponseEntity.ok(service.findById(id));
    }
}


Validation:

Use @Valid and JSR-380 annotations (@NotNull, @Email, @Size).

DTOs:

Avoid exposing Entities directly. Map Entity â†” DTO with tools like MapStruct or manual conversion.

HTTP Status Codes:

200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error.

Interview Q: How do you handle large JSON requests efficiently?
ðŸ‘‰ Use Spring Batch or Streaming (Jackson Streaming API) to process in chunks.

ðŸ”¹ 5. Error Handling

Centralized Handling:

@ControllerAdvice â†’ Global exception handler.

@ExceptionHandler â†’ Handle specific exceptions.

Example:

@ControllerAdvice
class GlobalExceptionHandler {
    @ExceptionHandler(ResourceNotFoundException.class)
    ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }
}


Best Practices:

Return proper HTTP status codes.

Use consistent error response model (timestamp, message, path).

ðŸ”¹ 6. Security (Spring Security + JWT)

Flow:

User logs in â†’ sends credentials.

Server validates â†’ generates JWT token with roles/expiry.

Client sends token in Authorization: Bearer <token>.

Filter (OncePerRequestFilter) validates JWT before passing request.

Example JWT Filter:

public class JwtAuthFilter extends OncePerRequestFilter {
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws ServletException, IOException {
        String token = req.getHeader("Authorization");
        if (token != null && validateToken(token)) {
            UsernamePasswordAuthenticationToken auth = getAuth(token);
            SecurityContextHolder.getContext().setAuthentication(auth);
        }
        chain.doFilter(req, res);
    }
}


Role-based Access Control:

@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(Long id) { ... }


Interview Q: Difference between Authentication vs Authorization?
ðŸ‘‰ Authentication â†’ verifies identity (login).
Authorization â†’ verifies what user can access (roles, permissions).

ðŸ”¹ 7. Testing in Spring Boot

Types of Tests:

@WebMvcTest â†’ for controllers (MockMvc).

@DataJpaTest â†’ for repositories (uses in-memory DB like H2).

@SpringBootTest â†’ full integration test.

Mockito Example:

@RunWith(MockitoJUnitRunner.class)
class UserServiceTest {
    @Mock UserRepository repo;
    @InjectMocks UserService service;

    @Test
    void testFindUser() {
        when(repo.findById(1L)).thenReturn(Optional.of(new User("John")));
        assertEquals("John", service.findById(1L).getName());
    }
}


Interview Q: Unit test vs Integration test?
ðŸ‘‰ Unit test â†’ small, isolated, mocks dependencies.
Integration test â†’ tests multiple layers together, uses real DB or embedded server.
