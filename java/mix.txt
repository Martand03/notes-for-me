ğŸ“˜ Java Core Revision
ğŸ”¹ OOPs & SOLID Principles

OOPs (Object-Oriented Programming):

Encapsulation â†’ Wrapping data + methods in one unit (class). Access controlled using private, public, protected. Example: private String password; with getters/setters.

Abstraction â†’ Hiding implementation details, showing only functionality. Done with abstract classes and interfaces.

Inheritance â†’ Reusing properties/methods of a parent class. Supports code reuse. Example: class Dog extends Animal.

Polymorphism â†’ â€œMany formsâ€.

Compile-time â†’ Method overloading.

Runtime â†’ Method overriding (via inheritance).

SOLID Principles:

Single Responsibility â†’ A class should have only one reason to change. Example: Separate InvoiceCalculator from InvoicePrinter.

Open/Closed â†’ Classes open for extension but closed for modification. Example: Use abstract class + subclasses instead of changing existing code.

Liskov Substitution â†’ Subtypes should replace parent types without breaking functionality. Example: A Square should work in place of a Rectangle.

Interface Segregation â†’ Prefer many small, specific interfaces over one large â€œfatâ€ interface.

Dependency Inversion â†’ Depend on abstractions, not concrete classes. Use interfaces and DI frameworks (Spring).

ğŸ”¹ Collections Framework

HashMap:

Stores key-value pairs. Keys must be unique.

Internally uses array of buckets â†’ each bucket is a linked list/tree.

Hashing process:

hashCode() gives hash.

Hash is mapped to bucket index.

Collision handled with chaining (Java 7: linked list, Java 8+: balanced tree for performance).

Performance: O(1) average for get/put, O(n) worst-case if too many collisions.

List vs Set:

List â†’ Ordered, allows duplicates. Implementations: ArrayList (dynamic array), LinkedList (doubly linked).

Set â†’ Unordered, unique elements. Implementations: HashSet (hash-based), TreeSet (sorted, uses Red-Black tree).

Example: Use List when order matters (e.g., history log), Set when uniqueness is required (e.g., usernames).

ğŸ”¹ Java 8 Features

Streams:

Functional style for collections.

Supports operations: map(), filter(), reduce(), collect().

Example:

List<String> names = Arrays.asList("A", "BB", "CCC");
List<String> result = names.stream()
                           .filter(n -> n.length() > 1)
                           .map(String::toUpperCase)
                           .toList();


Lazy evaluation (ops donâ€™t run until terminal op like collect()).

Lambdas:

Short syntax for anonymous functions.

(a, b) -> a + b replaces Comparator or Runnable.

Optional:

Container for null-safety. Avoids NPE.

Example:

Optional<String> name = Optional.ofNullable(user.getName());
name.ifPresent(System.out::println);


Functional Interfaces:

Interface with exactly one abstract method. Examples: Runnable, Comparator, Function<T,R>.

Used with Lambdas and method references.

ğŸ”¹ Multithreading

Thread Lifecycle:

New â†’ Created with new Thread().

Runnable â†’ After start(), waiting for CPU.

Running â†’ Actually executing.

Waiting/Timed waiting â†’ wait(), sleep().

Terminated â†’ After completion.

synchronized:

Ensures mutual exclusion (only one thread at a time).

Example:

synchronized void increment() { count++; }


volatile:

Guarantees visibility across threads but not atomicity.

Example: volatile boolean running = true; ensures thread sees latest value.

ExecutorService:

Thread pool for managing concurrent tasks.

Example:

ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(() -> System.out.println("Task"));
executor.shutdown();

ğŸ”¹ Exception Handling

Custom Exceptions:

Extend Exception (checked) or RuntimeException (unchecked).

Example:

public class InvalidUserException extends RuntimeException {
    public InvalidUserException(String message) { super(message); }
}


try-catch-finally:

try â†’ risk code.

catch â†’ handle exception.

finally â†’ always executes (good for resource cleanup).

Since Java 7, use try-with-resources for auto-close.

ğŸ”¹ Memory Management

Stack vs Heap:

Stack â†’ Stores method calls, local variables, primitive types. Faster.

Heap â†’ Stores objects, shared among threads. Managed by GC.

Garbage Collection:

Automatic memory cleanup.

In modern JVMs:

Young Gen (Eden + Survivor spaces) â†’ short-lived objects.

Old Gen â†’ long-lived objects.

GC Algorithms: G1 GC (region-based, low-pause), ZGC (scalable, <10ms pause).

ğŸŒ± Spring Boot Revision
ğŸ”¹ Core Annotations

@RestController â†’ Combination of @Controller + @ResponseBody. Directly returns JSON/XML.

@Service â†’ Marks business logic layer.

@Repository â†’ Marks DAO layer, also converts DB exceptions into Spring DataAccessException.

@Component â†’ Generic bean, used when others donâ€™t fit.

@Autowired â†’ Injects dependencies.

ğŸ”¹ Spring Internals

Starters:

Opinionated dependencies packaged by Spring Boot. Example: spring-boot-starter-web.

application.properties / application.yml:

Central config for DB, server port, logging, etc. Supports profiles (application-dev.yml).

Auto-configuration:

Spring Boot scans classpath + conditions (@ConditionalOnClass, etc.) to configure beans automatically.

Example: If spring-boot-starter-data-jpa is present, Hibernate + DataSource beans are auto-configured.

ğŸ”¹ JPA & Hibernate

Entity Mapping:

@Entity, @Table, @Id, @GeneratedValue.

Relationships: @OneToOne, @OneToMany, @ManyToMany.

@Transactional:

Ensures atomicity. Rolls back on runtime exceptions.

Propagation types control how nested transactions behave.

Lazy vs Eager:

Lazy â†’ Fetch only when needed (proxy). Default for collections.

Eager â†’ Fetch immediately with parent entity. Useful when data is always required.

ğŸ”¹ Error Handling

@ControllerAdvice â†’ Global exception handler.

@ExceptionHandler â†’ Maps specific exception to response.

Example:

@ControllerAdvice
public class GlobalHandler {
    @ExceptionHandler(ResourceNotFound.class)
    ResponseEntity<?> handle(ResourceNotFound e) {
        return ResponseEntity.status(404).body(e.getMessage());
    }
}

ğŸ”¹ RESTful APIs

CRUD Example:

@PostMapping("/users") â†’ Create.

@GetMapping("/users/{id}") â†’ Read.

@PutMapping("/users/{id}") â†’ Update.

@DeleteMapping("/users/{id}") â†’ Delete.

DTOs & Validation:

Use @Valid with @NotNull, @Size, etc.

Separate DTOs from Entities for cleaner APIs.

HTTP Status Codes:

200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error.

ğŸ”¹ Security Basics

JWT Authentication:

User logs in â†’ server validates and issues JWT.

JWT contains claims (roles, expiry).

Client sends token in Authorization: Bearer <token>.

Spring Security filter validates JWT before passing request.

Role-based Authorization:

Use @PreAuthorize("hasRole('ADMIN')") or method-level security.

ğŸ”¹ Testing

@WebMvcTest â†’ Test controllers with MockMvc.

@DataJpaTest â†’ Test repositories with in-memory DB (H2).

Mockito â†’ Mock dependencies for service tests. Example:

when(userRepo.findById(1L)).thenReturn(Optional.of(user));
